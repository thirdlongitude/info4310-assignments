<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF=8">
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/topojson.v3.min.js"></script>
  <style>
    #map-div {
      display: flex;
      flex-direction: row;
    }
  </style>
</head>

<body>
  <h1> INFO 4310 HW1 </h1>
  <p>
    The map shows the most common tree species in a region.
  </p>
  <p>
    (Don't worry, it's just loading really slowly)
  </p>

  <div id="map-div">
    <svg id="map-svg" height="770" width="900"></svg>
    <svg id="map-legend" height="770" width="300"></svg>
  </div>

  <script>
    // definitions
    const svg = d3.select("#map-svg");
    const width = svg.attr("width");
    const height = svg.attr("height");
    const margins = { top: 20, right: 20, bottom: 20, left: 20 };
    const mapWidth = width - margins.left - margins.right;
    const mapHeight = height - margins.top - margins.bottom;
    const map = svg.append("g")
      .attr("transform", "translate(" + margins.left + ", " + margins.top + ")");

    // load data file
    const requestData = async function () {
      const sf = await d3.json("SF-Neighborhoods.geo.json");
      console.log(sf);
      const trees = await d3.csv("trees_vis_data.csv");
      console.log(trees);

      // define topojson features
      let neighborhoods = topojson.feature(sf, sf.objects.SFNeighborhoods);
      let neighborhoodsMesh = topojson.mesh(sf, sf.objects.SFNeighborhoods);
      console.log(neighborhoods);
      console.log(neighborhoodsMesh);

      // define projection and path
      let projection = d3.geoMercator().fitSize([mapWidth, mapHeight], neighborhoods);
      let path = d3.geoPath().projection(projection);

      // color scale (generated by https://medialab.github.io/iwanthue/)
      const speciesScale = d3.scaleOrdinal().range(["#4d5988", "#b87db0", "#6a6c31", "#c7a275",
        "#c5c5c5", "#bc5155", "#d09d36", "#a3b040", "#467f3c", "#874161", "#5ab1c3", "#6bbc8f",
        "#e6773c", "#cd458f", "#7e3da3", "#626bd2", "#cc73d8", "#b73824", "#d98a95", "#db385b",
        "#7d5039", "#6192d2", "#a05e2b", "#3b7767", "#5ab84b"]);

      // process data (takes way too long :/)
      // find the dominant species of all neighborhoods
      let list_dom_species = [];
      for (let n = 0; n < neighborhoods.features.length; n++) {
        let neighborhood = neighborhoods.features[n];
        let species_dict = {}; // dict of {species: number of trees} for a neighborhood
        let t_found_n = Array(trees.length).fill(0); // array with len(trees) values; if the neighborhood of a tree has been found, change t_found_n[t] to 1
        let max_species_occ = 0;

        for (let t = 0; t < trees.length; t++) {
          let tree = trees[t];

          if (t_found_n[t] === 1) {
            break;
          }

          if (d3.geoContains(neighborhood, [tree.longitude, tree.latitude])) {
            // console.log(neighborhood);
            if (tree.species in species_dict) {
              species_dict[tree.species] += 1;
            } else {
              species_dict[tree.species] = 1;
            }

            t_found_n[t] = 1;

            if (species_dict[tree.species] > max_species_occ) {
              max_species_occ = species_dict[tree.species];
            }
          }
        }

        // find name of dominant species
        if (max_species_occ === 0) {
          // means that no trees are in this neighborhood
          // assign 'Unknown'
          neighborhoods.features[n].dom_species = "Unknown";
          if (list_dom_species.indexOf("Unknown") === -1) {
            list_dom_species.push("Unknown");
          }
        } else {
          // get name of species
          // might be 'Unknown' (not ideal but this is getting too complicated)
          neighborhoods.features[n].dom_species = Object.keys(species_dict).find(key => species_dict[key] === max_species_occ);
          if (list_dom_species.indexOf(neighborhoods.features[n].dom_species) === -1) {
            list_dom_species.push(neighborhoods.features[n].dom_species);
          }
        }
      }
      console.log(list_dom_species);

      // draw areas
      map.selectAll("path.neighborhoods").data(neighborhoods.features)
        .join("path")
        .attr("class", "neighborhoods")
        .attr("d", path)
        .attr("fill", d => speciesScale(d.dom_species));

      // draw outlines
      map.append("path").datum(neighborhoodsMesh)
        .attr("class", "outline")
        .attr("d", path)
        .attr("stroke", "white")
        .attr("stroke-width", 1)
        .attr("fill", "none");

      // make labels
      const circle_size = 12;
      const label_spacing = 17;
      const label_x_offset = 15;
      const label_y_offset = 15;

      let legend = d3.select("#map-legend")
        .append("g")
        .selectAll(".legend-item")
        .data(list_dom_species);

      legend.enter().append("circle")
        .attr("class", "legend-item")
        .attr("r", circle_size)
        .attr("fill", d => speciesScale(d))
        .attr("transform", (d, i) => {
          let x = label_x_offset;
          let y = label_y_offset + (circle_size + label_spacing) * i;
          return `translate(${x}, ${y})`;
        });

      legend.enter().append("text")
        .attr("x", label_x_offset + circle_size + 5)
        .attr("y", (d, i) => label_y_offset + (circle_size + label_spacing) * i + 10)
        .text(d => d);
    };

    requestData();
  </script>
</body>

</html>